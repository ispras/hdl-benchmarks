`include "inc.h"

//*******************************************************************************
//  S Y N T H E Z I A B L E      S D R A M     C O N T R O L L E R    C O R E
//
//  This core adheres to the GNU Public License  
//  www.cmosexod.com 
//
//  This is a synthesizable Synchronous DRAM controller Core. 
//
//  2Mbyte Version
//      512K x 2 banks x 16
//
//  The core has been carefully coded so as to be "platform-independent".  
//  It has been successfully compiled and simulated under three separate
//  FPGA/CPLD platforms:
//      Xilinx Foundation Base Express V2.1i
//      Altera Max+PlusII V9.21
//      Lattice ispExpert V7.0
//  
//  The interface to the host (i.e. microprocessor, DSP, etc) is synchronous
//  and supports ony one transfer at a time.  That is, burst-mode transfers
//  are not yet supported.  In may ways, the interface to this core is much
//  like that of a typical SRAM.  The hand-shaking between the host and the 
//  SDRAM core is done through the "sdram_busy_l" signal generated by the 
//  core.  Whenever this signal is active low, the host must hold the address,
//  data (if doing a write), size and the controls (cs, rd/wr).  
//
//  Connection Diagram:
//  SDRAM side:
//  sd_wr_l                     connect to -WR pin of SDRAM
//  sd_cs_l                     connect to -CS pin of SDRAM
//  sd_ras_l                    connect to -RAS pin of SDRAM
//  sd_cas_l                    connect to -CAS pin of SDRAM
//  sd_dqm[1:0]                 connect to the UDQM and LDQM (respectively) pins
//  sd_addx[10:0]               connect to the Address bus [10:0]
//  sd_data[15:0]               connect to the data bus [15:0]
//  sd_ba                       connect to BA pin of SDRAM
//   
//  HOST side:
//  mp_addx[20:0]               connect to the address bus of the host. 
//                              21 bit address bus give access to 2Mbyte
//                              of the SDRAM, as byte or half-word (16bit)
//  mp_data_in[15:0]            Unidirectional bus connected to the data out
//                              of the host. To use this, enable 
//                              "databus_is_unidirectional" in INC.H
//  mp_data_out[15:0]           Unidirectional bus connected to the data in 
//                              of the host.  To use this, enable
//                              "databus_is_unidirectional" in INC.H
//  mp_data[15:0]               Bi-directional bus connected to the host's
//                              data bus.  To use the bi-directionla bus,
//                              disable "databus_is_unidirectional" in INC.H
//  mp_rd_l                     Connect to the -RD output of the host
//  mp_wr_l                     Connect to the -WR output of the host
//  mp_cs_l                     Connect to the -CS of the host
//  mp_size[1:0]                Connect to the size output of the host
//                              if there is one.  When set to 0
//                              all trasnfers are 16 bits, when set to 1
//                              all transfers are 8 bits. If you want the
//                              data to be lower order aligned, turn on
//                              "align_data_bus" option in INC.H
//  sdram_busy_l                Connect this to the wait or hold equivalent
//                              input of the host.  The host, must hold the
//                              bus if it samples this signal as low.
//  sdram_mode_set_l            When a write occurs with this set low,
//                              the SDRAM's mode set register will be programmed
//                              with the data supplied on the data_bus[10:0].
//
//
//  Author:  Jeung Joon Lee  joon.lee@quantum.com,  cmosexod@ix.netcom.com
//  
//*******************************************************************************
//
//  Hierarchy:
//
//  SDRAM.V         Top Level Module
//  HOSTCONT.V      Controls the interfacing between the micro and the SDRAM
//  SDRAMCNT.V      This is the SDRAM controller.  All data passed to and from
//                  is with the HOSTCONT.
//  optional
//  MICRO.V         This is the built in SDRAM tester.  This module generates 
//                  a number of test logics which is used to test the SDRAM
//                  It is basically a Micro bus generator. 
//  
/*
*/ 



module os_sdram16(
            // SYSTEM LEVEL CONNECTIONS
            sys_rst_l,
`ifdef clock_debug
            main_sys_clk,
            main_sys_rst,
            sdram_clk,
`else
            sys_clk,
`endif
            // SDRAM CONNECTIONS
            sd_wr_l,
            sd_cs_l,
            sd_ras_l,
            sd_cas_l,
            sd_dqm,
            sd_addx,
            sd_data,
            sd_ba,
            // MICROPORCESSOR CONNECTION
            mp_addx
`ifdef databus_is_unidirectional
            ,
            mp_data_in,
            mp_data_out
`else
            ,
            mp_data,
`endif
            mp_rd_l,
            mp_wr_l,
            mp_cs_l,
            sdram_mode_set_l,
            sdram_busy_l,
            mp_size,
`ifdef simulate_mp
            data_is_correct
`endif


            // DEBUG
`ifdef show_debug
            ,            
            mp_data_out_sd,
            top_state,
			mp_simulator_data,
            sd_rd_ena,
            mp_size,
            next_state,
            burst_length_cntr,
            burst_cntr_ena,
            modereg_cas_latency,
            modereg_burst_length,

            mp_data_gate
            do_write,
            reg_mp_addx,
            reg_mp_data_mux,
            sd_addx_mux,
            sd_addx10_mux,
            next_state,
            doing_refresh,
            do_modeset,
            do_read,
            sd_addx_mux,
            sd_addx10_mux,
            autorefresh_cntr,
            autorefresh_cntr_l,
            pwrup,
            wr_cntr,
            mp_data_micro,
            mp_data_mux,
            sd_data_ena,
            mp_data_out,
            sd_addx_mux,
            sd_addx10_mux,
            sd_rd_ena
`endif
 );

// include this file for memory definition



// ****************************************
//
//   I/O  DEFINITION
//
// ****************************************
// SYSTEM LEVEL CONNECTIONS
input           sys_rst_l;              // global active low asynchronous system reset
`ifdef clock_debug
input           main_sys_clk;
input           main_sys_rst;
output          sdram_clk;              // clock going to SDRAM
`else
input           sys_clk;                // global system clock.  Runs the sdram state machine
`endif
// SDRAM CONNECTIONS
output          sd_wr_l;                // SDRAM active low WRITE signal
output          sd_cs_l;                // SDRAM active low chip select signal
output          sd_ras_l;               // SDRAM active low RAS 
output          sd_cas_l;               // SDRAM active low CAS
output  [1:0]   sd_dqm;                 // SDRAM data masks
output  [10:0]  sd_addx;                // SDRAM multiplexed address bus
inout   [15:0]  sd_data;                // SDRAM birectional data bus 32 bit
output                sd_ba;                  // SDRAM bank address , aka A11
// MICROPROCESSOR CONNECTION
`ifdef databus_is_unidirectional
input   [15:0]  mp_data_in;             
output  [15:0]  mp_data_out;
`else
`ifdef simulate_mp
output  [15:0]  mp_data;
output                data_is_correct;
`else
inout   [15:0]  mp_data;
`endif
`endif
`ifdef simulate_mp
output  [20:0]  mp_addx;                // HOST address bus. 21 bits for 2Mb
output          mp_rd_l;                // HOST active low READ 
output          mp_wr_l;                // HOST active low WRITE
output          mp_cs_l;                // HOST active low chip select
output          sdram_mode_set_l;
output  [1:0]   mp_size;
`else
input   [20:0]  mp_addx;                // HOST address bus. 21 bits for 2Mb
input           mp_rd_l;                // HOST active low READ 
input           mp_wr_l;                // HOST active low WRITE
input           mp_cs_l;                // HOST active low chip select
input           sdram_mode_set_l;
input   [1:0]   mp_size;                // 00=32bits, 10=16bits, 01=8bits
`endif
output          sdram_busy_l;



wire    [15:0]  mp_simulator_data;



// DEBUG
`ifdef show_debug
output          sd_rd_ena;
output  [1:0]   mp_size;                // 00=32bits, 10=16bits, 01=8bits
output  [3:0]   next_state;
output  [3:0]   burst_length_cntr;
output          burst_cntr_ena;
output  [2:0]   modereg_cas_latency;
output  [2:0]   modereg_burst_length;
output  [15:0]  mp_data_out_sd;
output  [3:0]   top_state;
output  [15:0]  mp_simulator_data;


output          mp_data_gate;
output          do_write;
output  [20:0]  reg_mp_addx;
output  [15:0]  reg_mp_data_mux;
output          sd_addx_mux;
output          sd_addx10_mux;
output          do_modeset;
output          do_read;
output          doing_refresh;
output  [12:0]  autorefresh_cntr;
output          autorefresh_cntr_l;
output          pwrup;
output  [7:0]   wr_cntr;
//output[`DATAn:0]  mp_data_micro;
output  [15:0]  mp_data_out;
//output        mp_data_mux;
output          sd_data_ena;
`endif


// INTER-MODULE CONNECTIONS
wire            do_modeset;
wire            do_read;
wire            do_write;
wire            doing_refresh;
wire            sd_addx_ena;
wire    [1:0]   sd_addx_mux;
wire    [1:0]   sd_addx10_mux;
wire            sd_rd_ena;
wire            sd_data_ena;
wire    [2:0]   modereg_cas_latency;
wire    [2:0]   modereg_burst_length;
wire    [3:0]   next_state;
wire    [15:0]  mp_data_out_sd;
wire    [15:0]  mp_data_in;
//wire  [15:0]  sd_data;
wire            mp_cs_l;
wire            mp_wr_l;
wire            mp_rd_l;
wire            mp_data_mux;
wire    [3:0]   autorefresh_cntr;
wire            autorefresh_cntr_l;
wire            pwrup;
wire    [3:0]   top_state;
wire    [20:0]  reg_mp_addx;
wire    [1:0]   decoded_dqm;
wire            do_write_ack;
wire            do_read_ack;
wire            do_modeset_ack;
wire    [15:0]  reg_mp_data_mux;
wire    [15:0]  sd_data_in;
wire    [15:0]  sd_data_out;
wire    [15:0]  reg_sd_data;
wire            sdram_mode_set_l;
wire            sdram_busy_l;
wire            mp_data_gate;
wire   [3:0]    burst_length_cntr;
wire            burst_cntr_ena;
`ifdef simulate_mp
wire            data_is_correct;
`endif



`ifdef clock_debug
reg     [1:0]   clock_divider;
wire            sys_clk,sdram_clk;
always @(posedge main_sys_clk or negedge main_sys_rst )
  if (~main_sys_rst)
      clock_divider <= 2'h0;
  else
      clock_divider <= clock_divider + 1;
assign sys_clk   = clock_divider[0];
assign sdram_clk = clock_divider[0];
`endif


//
// HOST sie DATA BUS DRISVERS
//
//
//
assign mp_data_gate = (~mp_wr_l & ~mp_cs_l);
// --- Unidirectional Data bus Mos
`ifdef databus_is_unidirectional
  `ifdef simulate_mp
     assign mp_data_out = mp_data_gate ? mp_simulator_data : mp_data_out_sd;     
  `else
     assign mp_data_out = mp_data_gate ? mp_data_out_sd : {16{1'b0}};
  `endif
// --- Bi-Directional Data bus Mode
`else
  `ifdef simulate_mp
     assign mp_data = mp_data_gate ? mp_simulator_data : mp_data_out_sd;     
  `else
     bufif1 m0  (mp_data[0],  mp_data_out_sd[0],  mp_data_gate);
     bufif1 m1  (mp_data[1],  mp_data_out_sd[1],  mp_data_gate);
     bufif1 m2  (mp_data[2],  mp_data_out_sd[2],  mp_data_gate);
     bufif1 m3  (mp_data[3],  mp_data_out_sd[3],  mp_data_gate);
     bufif1 m4  (mp_data[4],  mp_data_out_sd[4],  mp_data_gate);
     bufif1 m5  (mp_data[5],  mp_data_out_sd[5],  mp_data_gate);
     bufif1 m6  (mp_data[6],  mp_data_out_sd[6],  mp_data_gate);
     bufif1 m7  (mp_data[7],  mp_data_out_sd[7],  mp_data_gate);
     bufif1 m8  (mp_data[8],  mp_data_out_sd[8],  mp_data_gate);
     bufif1 m9  (mp_data[9],  mp_data_out_sd[9],  mp_data_gate);
     bufif1 m10 (mp_data[10], mp_data_out_sd[10], mp_data_gate);
     bufif1 m11 (mp_data[11], mp_data_out_sd[11], mp_data_gate);
     bufif1 m12 (mp_data[12], mp_data_out_sd[12], mp_data_gate);
     bufif1 m13 (mp_data[13], mp_data_out_sd[13], mp_data_gate);
     bufif1 m14 (mp_data[14], mp_data_out_sd[14], mp_data_gate);
     bufif1 m15 (mp_data[15], mp_data_out_sd[15], mp_data_gate);
/*
     bufif1 m16 (mp_data[16], mp_data_out_sd[16], mp_data_gate);
     bufif1 m17 (mp_data[17], mp_data_out_sd[17], mp_data_gate);
     bufif1 m18 (mp_data[18], mp_data_out_sd[18], mp_data_gate);
     bufif1 m19 (mp_data[19], mp_data_out_sd[19], mp_data_gate);
     bufif1 m20 (mp_data[20], mp_data_out_sd[20], mp_data_gate);
     bufif1 m21 (mp_data[21], mp_data_out_sd[21], mp_data_gate);
     bufif1 m22 (mp_data[22], mp_data_out_sd[22], mp_data_gate);
     bufif1 m23 (mp_data[23], mp_data_out_sd[23], mp_data_gate);
     bufif1 m24 (mp_data[24], mp_data_out_sd[24], mp_data_gate);
     bufif1 m25 (mp_data[25], mp_data_out_sd[25], mp_data_gate);
     bufif1 m26 (mp_data[26], mp_data_out_sd[26], mp_data_gate);
     bufif1 m27 (mp_data[27], mp_data_out_sd[27], mp_data_gate);
     bufif1 m28 (mp_data[28], mp_data_out_sd[28], mp_data_gate);
     bufif1 m29 (mp_data[29], mp_data_out_sd[29], mp_data_gate);
     bufif1 m30 (mp_data[30], mp_data_out_sd[30], mp_data_gate);
     bufif1 m31 (mp_data[31], mp_data_out_sd[31], mp_data_gate);
*/
     assign mp_data_in = mp_data;
  `endif
`endif


//
// SDRAM side bidirectional data bus drivers
//assign sd_data    = sd_data_ena ? sd_data_out : 32'hzzzzzzzz;
//
bufif1 b0  (sd_data[0],  sd_data_out[0],  sd_data_ena);
bufif1 b1  (sd_data[1],  sd_data_out[1],  sd_data_ena);
bufif1 b2  (sd_data[2],  sd_data_out[2],  sd_data_ena);
bufif1 b3  (sd_data[3],  sd_data_out[3],  sd_data_ena);
bufif1 b4  (sd_data[4],  sd_data_out[4],  sd_data_ena);
bufif1 b5  (sd_data[5],  sd_data_out[5],  sd_data_ena);
bufif1 b6  (sd_data[6],  sd_data_out[6],  sd_data_ena);
bufif1 b7  (sd_data[7],  sd_data_out[7],  sd_data_ena);
bufif1 b8  (sd_data[8],  sd_data_out[8],  sd_data_ena);
bufif1 b9  (sd_data[9],  sd_data_out[9],  sd_data_ena);
bufif1 b10 (sd_data[10], sd_data_out[10], sd_data_ena);
bufif1 b11 (sd_data[11], sd_data_out[11], sd_data_ena);
bufif1 b12 (sd_data[12], sd_data_out[12], sd_data_ena);
bufif1 b13 (sd_data[13], sd_data_out[13], sd_data_ena);
bufif1 b14 (sd_data[14], sd_data_out[14], sd_data_ena);
bufif1 b15 (sd_data[15], sd_data_out[15], sd_data_ena);
/*
bufif1 b16 (sd_data[16], sd_data_out[16], sd_data_ena);
bufif1 b17 (sd_data[17], sd_data_out[17], sd_data_ena);
bufif1 b18 (sd_data[18], sd_data_out[18], sd_data_ena);
bufif1 b19 (sd_data[19], sd_data_out[19], sd_data_ena);
bufif1 b20 (sd_data[20], sd_data_out[20], sd_data_ena);
bufif1 b21 (sd_data[21], sd_data_out[21], sd_data_ena);
bufif1 b22 (sd_data[22], sd_data_out[22], sd_data_ena);
bufif1 b23 (sd_data[23], sd_data_out[23], sd_data_ena);
bufif1 b24 (sd_data[24], sd_data_out[24], sd_data_ena);
bufif1 b25 (sd_data[25], sd_data_out[25], sd_data_ena);
bufif1 b26 (sd_data[26], sd_data_out[26], sd_data_ena);
bufif1 b27 (sd_data[27], sd_data_out[27], sd_data_ena);
bufif1 b28 (sd_data[28], sd_data_out[28], sd_data_ena);
bufif1 b29 (sd_data[29], sd_data_out[29], sd_data_ena);
bufif1 b30 (sd_data[30], sd_data_out[30], sd_data_ena);
bufif1 b31 (sd_data[31], sd_data_out[31], sd_data_ena);
*/
assign sd_data_in = sd_data;




//
// INSTANTIATE THE SDRAM STATE MACHINE
//
sdramcnt MYSDRAMCNT(    
             // system level stuff
                .sys_rst_l(sys_rst_l),
                .sys_clk(sys_clk),
        
             // SDRAM connections
                .sd_wr_l(sd_wr_l),
                .sd_cs_l(sd_cs_l),
                .sd_ras_l(sd_ras_l),
                .sd_cas_l(sd_cas_l),
                .sd_dqm(sd_dqm),
            
             // Host Controller connections
                .do_mode_set(do_modeset),
                .do_read(do_read),
                .do_write(do_write),
                .doing_refresh(doing_refresh),
                .sd_addx_mux(sd_addx_mux),
                .sd_addx10_mux(sd_addx10_mux),
                .sd_rd_ena(sd_rd_ena),
                .sd_data_ena(sd_data_ena),
                .modereg_cas_latency(modereg_cas_latency),
                .modereg_burst_length(modereg_burst_length),
                .mp_data_mux(mp_data_mux),
                .decoded_dqm(decoded_dqm),
                .do_write_ack(do_write_ack),
                .do_read_ack(do_read_ack),
                .do_modeset_ack(do_modeset_ack),
                .pwrup(pwrup),

            // debug
                .next_state(next_state),
                .autorefresh_cntr(autorefresh_cntr),
                .autorefresh_cntr_l(autorefresh_cntr_l),
                .burst_length_cntr(burst_length_cntr),
                .burst_cntr_ena(burst_cntr_ena)

    );



//
//  INSTANTIATE THE HOST INTERFACE LOGIC
// 
hostcont MYHOSTCONT(
            // system connections
                .sys_rst_l(sys_rst_l),            
                .sys_clk(sys_clk),

            // microprocessor side connections
                .mp_addx(mp_addx),
`ifdef simulate_mp
                .mp_data_in(mp_simulator_data),
`else
                .mp_data_in(mp_data_in),
`endif
                .mp_data_out(mp_data_out_sd),
                .mp_rd_l(mp_rd_l),
                .mp_wr_l(mp_wr_l),
                .mp_cs_l(mp_cs_l),
                .sdram_mode_set_l(sdram_mode_set_l),
                .sdram_busy_l(sdram_busy_l),
                .mp_size(mp_size),

            // SDRAM side connections
                .sd_addx(sd_addx),
                .sd_data_in(sd_data),
                .sd_data_out(sd_data_out),
                .sd_ba(sd_ba),

            // SDRAMCNT side
                .sd_addx10_mux(sd_addx10_mux),
                .sd_addx_mux(sd_addx_mux),
                .sd_rd_ena(sd_rd_ena),
                .do_read(do_read),
                .do_write(do_write),
                .doing_refresh(doing_refresh),
                .do_modeset(do_modeset),
                .modereg_cas_latency(modereg_cas_latency),
                .modereg_burst_length(modereg_burst_length),
                .mp_data_mux(mp_data_mux),
                .decoded_dqm(decoded_dqm),
                .do_write_ack(do_write_ack),
                .do_read_ack(do_read_ack),
                .do_modeset_ack(do_modeset_ack),
                .pwrup(pwrup),

            // debug
                .reg_mp_data_mux(reg_mp_data_mux),
                .reg_mp_addx(reg_mp_addx),
                .reg_sd_data(reg_sd_data)

             );


`ifdef simulate_mp
micro   SDRAM_TESTER(
                // system connections
                .sys_clk(sys_clk),
                .sys_rst_l(sys_rst_l),

                // Connections to the HOSTCONT.V
                .sdram_busy_l(sdram_busy_l),
                .mp_addx(mp_addx),
                .mp_data_out(mp_simulator_data),
                .mp_data_in(mp_data_out_sd),
                .mp_wr_l(mp_wr_l),
                .mp_rd_l(mp_rd_l),
                .mp_cs_l(mp_cs_l),
                .mp_size(mp_size),
                .next_state(next_state),
                .data_is_correct(data_is_correct),
                .sdram_mode_set_l(sdram_mode_set_l),            

                // debug
                .top_state(top_state)
);
`endif

endmodule


