`include "tst_inc.h"
`include "inc.h"


//*******************************************************************************
//  S Y N T H E Z I A B L E      S D R A M     C O N T R O L L E R    C O R E
//
//  This core adheres to the GNU Public License  
//  www.cmosexod.com 
//
//  This is a synthesizable Synchronous DRAM controller Core. 
//
//  2Mbyte Version
//      512K x 2 banks x 16
//
//  The core has been carefully coded so as to be "platform-independent".  
//  It has been successfully compiled and simulated under three separate
//  FPGA/CPLD platforms:
//      Xilinx Foundation Base Express V2.1i
//      Altera Max+PlusII V9.21
//      Lattice ispExpert V7.0
//  
//  The interface to the host (i.e. microprocessor, DSP, etc) is synchronous
//  and supports ony one transfer at a time.  That is, burst-mode transfers
//  are not yet supported.  In may ways, the interface to this core is much
//  like that of a typical SRAM.  The hand-shaking between the host and the 
//  SDRAM core is done through the "sdram_busy_l" signal generated by the 
//  core.  Whenever this signal is active low, the host must hold the address,
//  data (if doing a write), size and the controls (cs, rd/wr).  
//
//  Connection Diagram:
//  SDRAM side:
//  sd_wr_l                     connect to -WR pin of SDRAM
//  sd_cs_l                     connect to -CS pin of SDRAM
//  sd_ras_l                    connect to -RAS pin of SDRAM
//  sd_cas_l                    connect to -CAS pin of SDRAM
//  sd_dqm[1:0]                 connect to the UDQM and LDQM (respectively) pins
//  sd_addx[10:0]               connect to the Address bus [10:0]
//  sd_data[15:0]               connect to the data bus [15:0]
//  sd_ba                       connect to BA pin of SDRAM
//   
//  HOST side:
//  mp_addx[20:0]               connect to the address bus of the host. 
//                              21 bit address bus give access to 2Mbyte
//                              of the SDRAM, as byte or half-word (16bit)
//  mp_data_in[15:0]            Unidirectional bus connected to the data out
//                              of the host. To use this, enable 
//                              "databus_is_unidirectional" in INC.H
//  mp_data_out[15:0]           Unidirectional bus connected to the data in 
//                              of the host.  To use this, enable
//                              "databus_is_unidirectional" in INC.H
//  mp_data[15:0]               Bi-directional bus connected to the host's
//                              data bus.  To use the bi-directionla bus,
//                              disable "databus_is_unidirectional" in INC.H
//  mp_rd_l                     Connect to the -RD output of the host
//  mp_wr_l                     Connect to the -WR output of the host
//  mp_cs_l                     Connect to the -CS of the host
//  mp_size[1:0]                Connect to the size output of the host
//                              if there is one.  When set to 0
//                              all trasnfers are 16 bits, when set to 1
//                              all transfers are 8 bits. If you want the
//                              data to be lower order aligned, turn on
//                              "align_data_bus" option in INC.H
//  sdram_busy_l                Connect this to the wait or hold equivalent
//                              input of the host.  The host, must hold the
//                              bus if it samples this signal as low.
//  sdram_mode_set_l            When a write occurs with this set low,
//                              the SDRAM's mode set register will be programmed
//                              with the data supplied on the data_bus[10:0].
//
//
//  Author:  Jeung Joon Lee  joon.lee@quantum.com,  cmosexod@ix.netcom.com
//  
//*******************************************************************************
//
//  Hierarchy:
//
//  SDRAM.V         Top Level Module
//  HOSTCONT.V      Controls the interfacing between the micro and the SDRAM
//  SDRAMCNT.V      This is the SDRAM controller.  All data passed to and from
//                  is with the HOSTCONT.
//  optional
//  MICRO.V         This is the built in SDRAM tester.  This module generates 
//                  a number of test logics which is used to test the SDRAM
//                  It is basically a Micro bus generator. 
//  
/*
*/ 

module micro(
                // system connections
                sys_clk,
                sys_rst_l,

                // Connections to the HOSTCONT.V
                sdram_busy_l,
                mp_addx,
                mp_data_out,
                mp_data_in,
                mp_wr_l,
                mp_rd_l,
                mp_cs_l,
                mp_size,
                next_state,
                data_is_correct,
                sdram_mode_set_l,           

                // debug
                top_state
				                
);




// ****************************************
//
//   I/O  DEFINITION
//
// ****************************************
// system connections
input           sys_clk;            // main system clock
input           sys_rst_l;          // main system reset

// connections to the SDRAM CONTROLLER
input           sdram_busy_l;       
output  [20:0]  mp_addx;
output          mp_wr_l;
output          mp_rd_l;
output          mp_cs_l;
output  [1:0]   mp_size;
input   [3:0]   next_state;
output  [15:0]  mp_data_out;        // data bus to the SDRAM controller
input   [15:0]  mp_data_in;         // data bus from the SDRAM controller
output          data_is_correct;
output          sdram_mode_set_l;

// debug
output  [3:0]   top_state;

// Intermodule connections
wire    [7:0]   bus_state;
wire            data_ena;
wire    [15:0]  mp_data_out;
wire    [15:0]  mp_data_in;
wire    [1:0]   mp_size;

// Memory element definitions
reg     [3:0]   top_state;
reg             mp_cs_l;
reg             mp_wr_l;
reg             mp_rd_l;
reg     [15:0]  reg_mp_data_out;
reg     [20:0]  reg_mp_addx;
reg     [20:0]  reg_byte_counter;
reg             data_is_correct;
reg             sdram_mode_set_l;


/*
** SINGLE WRITE FOLLOWED BY GAP THEN FOLLOWED BY SINGLE READ TEST
**
*/
`ifdef do_read_write_test
`endif


/*
** BURST WRITE FOLLOWED BY GAP THEN FOLLOWED BY BURST READ TEST
**
*/
`ifdef do_burst_write_read_test

`endif


/*
** A ONE-TIME BURST WRITE FOLLOWED BY GAP THEN FOLLOWED BY MANY BURST READ TEST
**
*/
`ifdef do_single_burst_write_read_test

// the number of  write/read in the test
`define     RW_COUNT           21'h0015
//`define     RW_COUNT           21'h1FFFFF
// number of clock ticks between the reads.
//`define     GAP_DELAY          23'h000030   
`define     GAP_DELAY          21'h00FF   
// define the amount of address delta
// 2 for 16 bit mode
// 1 for byte mode
`define     MP_ADDX_DELTA       21'h000002
// define the amount of data delta
`define     MP_DATA_DELTA       16'h1234


// Micro Simulator State Machine State Definitions
`define         powerup_delay            4'h0
`define         burst_write_cs           4'h1
`define         burst_write_assert_wr    4'h2
`define         burst_write_wait_4_busy  4'h3
`define         burst_write_deassert_wr  4'h4
`define         burst_wr_rd_delay        4'h5
`define         burst_read_cs            4'h6
`define         burst_read_assert_rd     4'h7
`define         burst_read_wait_4_busy   4'h8
`define         burst_read_deassert_rd   4'h9
`define         request_modereg          4'ha

// true for 32 bit bus
`define         SIZE_IS_BYTE        2'b01
`define         SIZE_IS_HALF_WORD   2'b10
`define         SIZE_IS_WORD        2'b00
`define         DIR                 1'b1

assign  mp_size      = `SIZE_IS_WORD;
assign  mp_addx      = reg_mp_addx;
assign  mp_data_out  = reg_mp_data_out;

always @(posedge sys_clk or negedge sys_rst_l)
  if (~sys_rst_l) begin
     top_state          <= `powerup_delay;      // initialze state
     mp_cs_l <= `HI;
     mp_wr_l <= `HI;
     mp_rd_l <= `HI;     
     reg_mp_addx        <= {21{`DIR}};          // reset address counter
     reg_mp_data_out    <= {16{1'b0}};        // reset data counter
     reg_byte_counter   <= {21{1'b0}};          // clear byte counter
     data_is_correct    <= `HI;                 // correct by default
     sdram_mode_set_l   <= `HI;                 // do not issue mode reg change by default
  end
  else case (top_state)   

     // Wait until the SDRAM has completed its power-up sequences
     `powerup_delay:  begin
          sdram_mode_set_l <= `HI;
          if (next_state==`state_idle) 
            top_state <= `burst_write_cs;// go and do burst write
          else
            top_state <= `powerup_delay;
      end
       
     // Assert MP CS to begin the write
     `burst_write_cs:  begin
         mp_cs_l  <= `LO;
         top_state   <= `burst_write_assert_wr;
     end

    // Assert MP WR 
    `burst_write_assert_wr: begin
         mp_wr_l <= `LO;
         top_state <= `burst_write_wait_4_busy;
    end
        
    // Wait until the SDRAM controller is no longer busy
    `burst_write_wait_4_busy:
         if (~sdram_busy_l)
            top_state <= `burst_write_wait_4_busy;
         else 
            top_state <= `burst_write_deassert_wr;

    // Deassert the WR, and check to see if it has completed all writes     
    `burst_write_deassert_wr:  begin
        mp_wr_l   <= `HI;       // deassert WR
        if (reg_byte_counter == `RW_COUNT) begin
            reg_mp_addx <= {21{`DIR}} ;
            reg_mp_data_out <= 0;
            reg_byte_counter <= 0;              // reset the counter
            mp_cs_l <= `HI;
            top_state <= `burst_wr_rd_delay;
        end else begin
            reg_mp_addx      <= reg_mp_addx      - `MP_ADDX_DELTA;
            reg_mp_data_out  <= reg_mp_data_out  + `MP_DATA_DELTA;
            reg_byte_counter <= reg_byte_counter + 1;       // one IO done
            top_state <= `burst_write_assert_wr;
        end
    end 
    
    // Wait here and kill GAP_DELAY number of cycles
    `burst_wr_rd_delay:  
        if (reg_byte_counter != `GAP_DELAY) begin
            reg_byte_counter <= reg_byte_counter + 1;
            top_state <= `burst_wr_rd_delay;
        end else begin
            reg_byte_counter <= {21{1'b0}};
            top_state <= `burst_read_cs;
        end

     // Assert MP CS to prepare for reads
     `burst_read_cs: begin
        mp_cs_l <= `LO;     // assert CS
        top_state <= `burst_read_assert_rd;
      end
      
      // Assert MP RD
     `burst_read_assert_rd: begin
        mp_rd_l <= `LO;
        top_state <= `burst_read_wait_4_busy;
     end

     // Wait until the SDRAM Controller is no longer busy
     `burst_read_wait_4_busy: 
        if (~sdram_busy_l)
            top_state <= `burst_read_wait_4_busy;
        else  begin
            top_state <= `burst_read_deassert_rd;
            // It is okay to sample data now, so see if it
            // is what was expected
            if (mp_data_in == reg_mp_data_out) data_is_correct <= `HI;
            else data_is_correct <= `LO;
        end
            
     // Deassert MP RD and Prepare for the next resd, 
     `burst_read_deassert_rd: begin  
        mp_rd_l   <= `HI;       // deassert RD
        if (reg_byte_counter == `RW_COUNT) begin
            reg_mp_addx <= {21{`DIR}};
            reg_mp_data_out <= 0;
            reg_byte_counter <= 0;              // reset the counter
            mp_cs_l <= `HI;
            top_state <= `burst_wr_rd_delay;
        end else begin
            reg_mp_addx      <= reg_mp_addx      - `MP_ADDX_DELTA;  // increment addx
            reg_mp_data_out  <= reg_mp_data_out  + `MP_DATA_DELTA;  // increment data expected
            reg_byte_counter <= reg_byte_counter + 1;       // one IO done
            top_state <= `burst_read_assert_rd;         
        end
     end

  endcase

  
`endif


endmodule

